// Copyright (c) 2023
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Jules Helper

#include "raylib/raycloud.h"
#include "raylib/rayparse.h"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath> // For std::pow
#include <numeric> // For std::iota (potentially for debugging)
#include <algorithm> // For std::min

// TEMPORARY: Assume common defaults if raylibconfig.h isn't easily included by a tool's cpp directly.
// This should ideally come from a config header.
#ifndef RAYLIB_DOUBLE_RAYS
#define RAYLIB_DOUBLE_RAYS 0 // common default
#endif
#ifndef RAYLIB_WITH_NORMAL_FIELD
#define RAYLIB_WITH_NORMAL_FIELD 1 // common default
#endif

bool saveRayCloudWithUncertainty(
    const std::string& file_name,
    const ray::Cloud& cloud,
    const std::vector<double>& uncertainties)
{
    if (cloud.rayCount() == 0) {
        std::cout << "Warning: Attempting to save an empty point cloud to " << file_name << std::endl;
        std::ofstream ofs(file_name, std::ios::binary | std::ios::out);
        if (!ofs) {
            std::cerr << "Error: Cannot open " << file_name << " for writing." << std::endl;
            return false;
        }
        ofs << "ply" << std::endl;
        ofs << "format binary_little_endian 1.0" << std::endl;
        ofs << "comment generated by raynoise tool - empty cloud" << std::endl;
        ofs << "element vertex 0" << std::endl;
#if RAYLIB_DOUBLE_RAYS
        ofs << "property double x" << std::endl;
        ofs << "property double y" << std::endl;
        ofs << "property double z" << std::endl;
#else
        ofs << "property float x" << std::endl;
        ofs << "property float y" << std::endl;
        ofs << "property float z" << std::endl;
#endif
        ofs << "property double time" << std::endl;
#if RAYLIB_WITH_NORMAL_FIELD
        ofs << "property float nx" << std::endl;
        ofs << "property float ny" << std::endl;
        ofs << "property float nz" << std::endl;
#else
        ofs << "property float rayx" << std::endl;
        ofs << "property float rayy" << std::endl;
        ofs << "property float rayz" << std::endl;
#endif
        ofs << "property uchar red" << std::endl;
        ofs << "property uchar green" << std::endl;
        ofs << "property uchar blue" << std::endl;
        ofs << "property uchar alpha" << std::endl;
        ofs << "property double uncertainty" << std::endl; // Even for empty, list properties
        ofs << "end_header" << std::endl;
        ofs.close();
        return true;
    }

    if (cloud.rayCount() != uncertainties.size()) {
        std::cerr << "Error: Mismatch between point cloud size (" << cloud.rayCount()
                  << ") and uncertainties vector size (" << uncertainties.size() << ")." << std::endl;
        return false;
    }

    std::ofstream ofs(file_name, std::ios::binary | std::ios::out);
    if (!ofs) {
        std::cerr << "Error: Cannot open " << file_name << " for writing." << std::endl;
        return false;
    }

    ofs << "ply" << std::endl;
    ofs << "format binary_little_endian 1.0" << std::endl;
    ofs << "comment generated by raynoise tool" << std::endl;
    ofs << "element vertex " << cloud.rayCount() << std::endl;

#if RAYLIB_DOUBLE_RAYS
    ofs << "property double x" << std::endl;
    ofs << "property double y" << std::endl;
    ofs << "property double z" << std::endl;
    using coord_type = double;
#else
    ofs << "property float x" << std::endl;
    ofs << "property float y" << std::endl;
    ofs << "property float z" << std::endl;
    using coord_type = float;
#endif

    ofs << "property double time" << std::endl;

#if RAYLIB_WITH_NORMAL_FIELD
    ofs << "property float nx" << std::endl;
    ofs << "property float ny" << std::endl;
    ofs << "property float nz" << std::endl;
#else
    ofs << "property float rayx" << std::endl;
    ofs << "property float rayy" << std::endl;
    ofs << "property float rayz" << std::endl;
#endif
    using ray_comp_type = float;

    ofs << "property uchar red" << std::endl;
    ofs << "property uchar green" << std::endl;
    ofs << "property uchar blue" << std::endl;
    ofs << "property uchar alpha" << std::endl;

    ofs << "property double uncertainty" << std::endl;
    using uncertainty_type = double;

    ofs << "end_header" << std::endl;

    // Binary data writing
    for (size_t i = 0; i < cloud.rayCount(); ++i) {
        coord_type px = static_cast<coord_type>(cloud.ends[i].x());
        coord_type py = static_cast<coord_type>(cloud.ends[i].y());
        coord_type pz = static_cast<coord_type>(cloud.ends[i].z());
        ofs.write(reinterpret_cast<const char*>(&px), sizeof(coord_type));
        ofs.write(reinterpret_cast<const char*>(&py), sizeof(coord_type));
        ofs.write(reinterpret_cast<const char*>(&pz), sizeof(coord_type));

        double time_val = cloud.times[i];
        ofs.write(reinterpret_cast<const char*>(&time_val), sizeof(double));

        Eigen::Vector3d ray_vec = cloud.starts[i] - cloud.ends[i]; // For PLY, often it's view vector (origin - point)
                                                                  // Or normal (if RAYLIB_WITH_NORMAL_FIELD)
                                                                  // Here, using (start - end) as 'ray vector'
                                                                  // If normals are available and desired, use cloud.normals[i]
#if RAYLIB_WITH_NORMAL_FIELD
        // Assuming normals are precalculated or available if this path is taken
        // For now, let's stick to ray vector calculation for consistency unless normals are explicitly loaded/computed
        // If cloud.normals is populated, use that. Otherwise, this calculation is a placeholder.
        // Defaulting to (end - start).normalized() if normals are expected but not computed from (start - end)
        Eigen::Vector3d normal_vec = (cloud.ends[i] - cloud.starts[i]).normalized(); // Example: ray direction as normal
        if (cloud.normals.size() == cloud.rayCount()){
            normal_vec = cloud.normals[i];
        }

        ray_comp_type nx = static_cast<ray_comp_type>(normal_vec.x());
        ray_comp_type ny = static_cast<ray_comp_type>(normal_vec.y());
        ray_comp_type nz = static_cast<ray_comp_type>(normal_vec.z());
        ofs.write(reinterpret_cast<const char*>(&nx), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&ny), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&nz), sizeof(ray_comp_type));
#else
        ray_comp_type rx = static_cast<ray_comp_type>(ray_vec.x());
        ray_comp_type ry = static_cast<ray_comp_type>(ray_vec.y());
        ray_comp_type rz = static_cast<ray_comp_type>(ray_vec.z());
        ofs.write(reinterpret_cast<const char*>(&rx), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&ry), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&rz), sizeof(ray_comp_type));
#endif


        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].red), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].green), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].blue), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].alpha), sizeof(uint8_t));

        uncertainty_type unc_val = uncertainties[i];
        ofs.write(reinterpret_cast<const char*>(&unc_val), sizeof(uncertainty_type));

        if (!ofs.good()) {
            std::cerr << "Error: Failed to write data for point " << i << " to " << file_name << std::endl;
            ofs.close(); // Close file before returning
            return false;
        }
    }

    ofs.close();
    // std::cout << "Successfully saved point cloud with uncertainty to " << file_name << std::endl; // Moved to rayNoiseMain
    return true;
}


// Function to calculate uncertainty for each point
std::vector<double> CalculatePointUncertainty(
    const ray::Cloud& pointCloud,
    double base_range_accuracy,
    double base_angle_accuracy,
    double c_intensity,
    double epsilon)
{
    std::vector<double> uncertainties;
    if (pointCloud.rayCount() == 0) {
        return uncertainties; // Return empty if cloud is empty
    }
    uncertainties.reserve(pointCloud.rayCount());

    double base_range_variance = std::pow(base_range_accuracy, 2);
    double base_angle_variance = std::pow(base_angle_accuracy, 2);

    for (size_t i = 0; i < pointCloud.rayCount(); ++i) {
        const Eigen::Vector3d& point_pos = pointCloud.ends[i];
        const Eigen::Vector3d& origin_pos = pointCloud.starts[i];

        Eigen::Vector3d d_vec = point_pos - origin_pos;
        double range_squared = d_vec.squaredNorm();

        uint8_t alpha_intensity = pointCloud.colours[i].alpha;
        float normalized_intensity = static_cast<float>(alpha_intensity) / 255.0f;

        double intensity_term = normalized_intensity + epsilon;
        if (intensity_term <= 0) {
            intensity_term = epsilon;
        }

        double range_uncertainty_variance = base_range_variance * (1.0 + c_intensity / intensity_term);
        double angular_uncertainty_variance = range_squared * base_angle_variance;
        double total_variance = range_uncertainty_variance + angular_uncertainty_variance;

        uncertainties.push_back(total_variance);
    }
    return uncertainties;
}

void print_usage(int exit_code = 1) {
    // clang-format off
    std::cout << "raynoise: Calculates positional uncertainty for point cloud data." << std::endl;
    std::cout << "Usage: raynoise <input_file> <output_file> [options]" << std::endl;
    std::cout << std::endl;
    std::cout << "Required arguments:" << std::endl;
    std::cout << "  <input_file>          Input point cloud file (PLY or LAZ)" << std::endl;
    std::cout << "  <output_file>         Output point cloud file with uncertainty" << std::endl;
    std::cout << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  --base_range_accuracy <value> (-r <value>)" << std::endl;
    std::cout << "                        Sensor's base 1-sigma range accuracy (m)." << std::endl;
    std::cout << "                        Default: 0.02" << std::endl;
    std::cout << "  --base_angle_accuracy <value> (-a <value>)" << std::endl;
    std::cout << "                        Sensor's base 1-sigma angular accuracy (rad)." << std::endl;
    std::cout << "                        Default: 0.0035" << std::endl;
    std::cout << "  --c_intensity <value> (-c <value>)" << std::endl;
    std::cout << "                        Coefficient for intensity effect." << std::endl;
    std::cout << "                        Default: 0.5" << std::endl;
    std::cout << "  --epsilon <value> (-e <value>)" << std::endl;
    std::cout << "                        Small value for intensity division." << std::endl;
    std::cout << "                        Default: 0.01" << std::endl;
    std::cout << "  --help (-h)           Print this usage message." << std::endl;
    // clang-format on
    exit(exit_code);
}

int rayNoiseMain(int argc, char* argv[]) {
    ray::FileArgument inputFile;
    ray::FileArgument outputFile;

    ray::DoubleArgument baseRangeAccuracyArg(0.0, 10.0, 0.02);
    ray::DoubleArgument baseAngleAccuracyArg(0.0, 1.0, 0.0035);
    ray::DoubleArgument cIntensityArg(0.0, 100.0, 0.5);
    ray::DoubleArgument epsilonArg(1e-9, 1.0, 0.01);

    ray::OptionalFlagArgument helpFlag("help", 'h');
    ray::OptionalKeyValueArgument baseRangeOpt("base_range_accuracy", 'r', &baseRangeAccuracyArg);
    ray::OptionalKeyValueArgument baseAngleOpt("base_angle_accuracy", 'a', &baseAngleAccuracyArg);
    ray::OptionalKeyValueArgument cIntensityOpt("c_intensity", 'c', &cIntensityArg);
    ray::OptionalKeyValueArgument epsilonOpt("epsilon", 'e', &epsilonArg);

    std::vector<ray::FixedArgument*> fixedArgs = {&inputFile, &outputFile};
    std::vector<ray::OptionalArgument*> optionalArgs = {&helpFlag, &baseRangeOpt, &baseAngleOpt, &cIntensityOpt, &epsilonOpt};

    if (!ray::parseCommandLine(argc, argv, fixedArgs, optionalArgs)) {
        if (argc == 1 || helpFlag.isSet()) {
             print_usage(0);
        }
        print_usage(1);
    }
     if (helpFlag.isSet()) {
        print_usage(0);
    }

    std::string input_file_str = inputFile.name();
    std::string output_file_str = outputFile.name();

    double base_range_accuracy = baseRangeAccuracyArg.value();
    double base_angle_accuracy = baseAngleAccuracyArg.value();
    double c_intensity = cIntensityArg.value();
    double epsilon = epsilonArg.value();

    if (epsilon <= 0) {
        std::cerr << "Error: Epsilon must be a positive value." << std::endl;
        print_usage(1);
    }

    ray::Cloud pointCloud;
    if (!pointCloud.load(input_file_str, true, 0)) {
        std::cerr << "Error: Could not load point cloud from " << input_file_str << std::endl;
        return 1;
    }

    if (pointCloud.rayCount() == 0) {
        std::cout << "Warning: Point cloud from " << input_file_str << " is empty. No uncertainties to calculate." << std::endl;
        // Call save function to write an empty PLY file with header.
        std::vector<double> empty_uncertainties;
        if (!saveRayCloudWithUncertainty(output_file_str, pointCloud, empty_uncertainties)) {
            std::cerr << "Error: Failed to save empty point cloud with header." << std::endl;
            return 1;
        }
        std::cout << "Empty point cloud with header saved to " << output_file_str << std::endl;
        return 0;
    }

    if (pointCloud.starts.size() != pointCloud.rayCount() ||
        pointCloud.ends.size() != pointCloud.rayCount() ||
        pointCloud.colours.size() != pointCloud.rayCount() ||
        pointCloud.times.size() != pointCloud.rayCount()) { // times is now required by save function
        std::cerr << "Error: Inconsistent data sizes in loaded point cloud." << std::endl;
        std::cerr << "  Ray count: " << pointCloud.rayCount() << std::endl;
        std::cerr << "  Starts size: " << pointCloud.starts.size() << std::endl;
        std::cerr << "  Ends size: " << pointCloud.ends.size() << std::endl;
        std::cerr << "  Colours size: " << pointCloud.colours.size() << std::endl;
        std::cerr << "  Times size: " << pointCloud.times.size() << std::endl;
        return 1;
    }

    std::vector<double> uncertainties = CalculatePointUncertainty(
        pointCloud, base_range_accuracy, base_angle_accuracy, c_intensity, epsilon);

    std::cout << "Successfully calculated uncertainties for " << uncertainties.size() << " points." << std::endl;
    std::cout << "Input: " << input_file_str << std::endl;

    if (!saveRayCloudWithUncertainty(output_file_str, pointCloud, uncertainties)) {
        std::cerr << "Error: Failed to save point cloud with uncertainty to " << output_file_str << std::endl;
        return 1;
    }
    // Success message moved into saveRayCloudWithUncertainty or implicitly handled by lack of error.
    // std::cout << "Output: " << output_file_str << std::endl; // Redundant if save is successful

    return 0;
}

int main(int argc, char* argv[]) {
    return rayNoiseMain(argc, argv);
}
