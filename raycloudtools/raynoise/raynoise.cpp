// Copyright (c) 2023
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Jules Helper

#include "raylib/raycloud.h"
#include "raylib/rayparse.h"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath> // For std::pow
#include <numeric> // For std::iota
#include <algorithm> // For std::min

// TEMPORARY: Assume common defaults if raylibconfig.h isn't easily included by a tool's cpp directly.
// This should ideally come from a config header.
#ifndef RAYLIB_DOUBLE_RAYS
#define RAYLIB_DOUBLE_RAYS 0 // common default
#endif
#ifndef RAYLIB_WITH_NORMAL_FIELD
#define RAYLIB_WITH_NORMAL_FIELD 1 // common default
#endif

bool saveRayCloudWithUncertainty(
    const std::string& file_name,
    const ray::Cloud& cloud,
    const std::vector<double>& uncertainties)
{
    if (cloud.rayCount() == 0) {
        std::ofstream ofs(file_name, std::ios::binary | std::ios::out);
        if (!ofs) {
            std::cerr << "Error: Cannot open " << file_name << " for writing." << std::endl;
            return false;
        }
        ofs << "ply" << std::endl;
        ofs << "format binary_little_endian 1.0" << std::endl;
        ofs << "comment generated by raynoise tool - empty cloud" << std::endl;
        ofs << "element vertex 0" << std::endl;
#if RAYLIB_DOUBLE_RAYS
        ofs << "property double x" << std::endl;
        ofs << "property double y" << std::endl;
        ofs << "property double z" << std::endl;
#else
        ofs << "property float x" << std::endl;
        ofs << "property float y" << std::endl;
        ofs << "property float z" << std::endl;
#endif
        ofs << "property double time" << std::endl;
#if RAYLIB_WITH_NORMAL_FIELD
        ofs << "property float nx" << std::endl;
        ofs << "property float ny" << std::endl;
        ofs << "property float nz" << std::endl;
#else
        ofs << "property float rayx" << std::endl;
        ofs << "property float rayy" << std::endl;
        ofs << "property float rayz" << std::endl;
#endif
        ofs << "property uchar red" << std::endl;
        ofs << "property uchar green" << std::endl;
        ofs << "property uchar blue" << std::endl;
        ofs << "property uchar alpha" << std::endl;
        ofs << "property double uncertainty" << std::endl;
        ofs << "end_header" << std::endl;
        ofs.close();
        return true;
    }

    if (cloud.rayCount() != uncertainties.size()) {
        std::cerr << "Error: Mismatch between point cloud size (" << cloud.rayCount()
                  << ") and uncertainties vector size (" << uncertainties.size() << ")." << std::endl;
        return false;
    }

    std::ofstream ofs(file_name, std::ios::binary | std::ios::out);
    if (!ofs) {
        std::cerr << "Error: Cannot open " << file_name << " for writing." << std::endl;
        return false;
    }

    ofs << "ply" << std::endl;
    ofs << "format binary_little_endian 1.0" << std::endl;
    ofs << "comment generated by raynoise tool" << std::endl;
    ofs << "element vertex " << cloud.rayCount() << std::endl;

#if RAYLIB_DOUBLE_RAYS
    ofs << "property double x" << std::endl;
    ofs << "property double y" << std::endl;
    ofs << "property double z" << std::endl;
    using coord_type = double;
#else
    ofs << "property float x" << std::endl;
    ofs << "property float y" << std::endl;
    ofs << "property float z" << std::endl;
    using coord_type = float;
#endif

    ofs << "property double time" << std::endl;

#if RAYLIB_WITH_NORMAL_FIELD
    ofs << "property float nx" << std::endl;
    ofs << "property float ny" << std::endl;
    ofs << "property float nz" << std::endl;
#else
    ofs << "property float rayx" << std::endl;
    ofs << "property float rayy" << std::endl;
    ofs << "property float rayz" << std::endl;
#endif
    using ray_comp_type = float;

    ofs << "property uchar red" << std::endl;
    ofs << "property uchar green" << std::endl;
    ofs << "property uchar blue" << std::endl;
    ofs << "property uchar alpha" << std::endl;

    ofs << "property double uncertainty" << std::endl;
    using uncertainty_type = double;

    ofs << "end_header" << std::endl;

    for (size_t i = 0; i < cloud.rayCount(); ++i) {
        coord_type px = static_cast<coord_type>(cloud.ends[i].x());
        coord_type py = static_cast<coord_type>(cloud.ends[i].y());
        coord_type pz = static_cast<coord_type>(cloud.ends[i].z());
        ofs.write(reinterpret_cast<const char*>(&px), sizeof(coord_type));
        ofs.write(reinterpret_cast<const char*>(&py), sizeof(coord_type));
        ofs.write(reinterpret_cast<const char*>(&pz), sizeof(coord_type));

        double time_val = cloud.times[i];
        ofs.write(reinterpret_cast<const char*>(&time_val), sizeof(double));

        Eigen::Vector3d ray_vec = cloud.starts[i] - cloud.ends[i];
        ray_comp_type rvx = static_cast<ray_comp_type>(ray_vec.x());
        ray_comp_type rvy = static_cast<ray_comp_type>(ray_vec.y());
        ray_comp_type rvz = static_cast<ray_comp_type>(ray_vec.z());
        ofs.write(reinterpret_cast<const char*>(&rvx), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&rvy), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&rvz), sizeof(ray_comp_type));

        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].red), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].green), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].blue), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].alpha), sizeof(uint8_t));

        uncertainty_type unc_val = uncertainties[i];
        ofs.write(reinterpret_cast<const char*>(&unc_val), sizeof(uncertainty_type));

        if (!ofs.good()) {
            std::cerr << "Error: Failed to write data for point " << i << " to " << file_name << std::endl;
            ofs.close();
            return false;
        }
    }
    ofs.close();
    return true;
}

// Add new parameters c_aoi, epsilon_aoi to CalculatePointUncertainty
std::vector<double> CalculatePointUncertainty(
    const ray::Cloud& pointCloud,
    double base_range_accuracy,
    double base_angle_accuracy,
    double c_intensity,
    double epsilon,
    double c_aoi, // New parameter
    double epsilon_aoi) // New parameter
{
    std::vector<double> uncertainties;
    if (pointCloud.rayCount() == 0) {
        return uncertainties;
    }
    uncertainties.reserve(pointCloud.rayCount());

    double base_range_variance = std::pow(base_range_accuracy, 2);
    double base_angle_variance = std::pow(base_angle_accuracy, 2);

    // TEMPORARY WORKAROUND: Create a non-const copy to generate normals. This is inefficient.
    ray::Cloud tempCloud = pointCloud; // Inefficient copy for non-const method
    std::vector<Eigen::Vector3d> surface_normals = tempCloud.generateNormals();

    bool normals_valid = (surface_normals.size() == pointCloud.rayCount());
    if (!normals_valid) {
        std::cerr << "Warning: Number of generated normals (" << surface_normals.size()
                  << ") does not match point count (" << pointCloud.rayCount()
                  << "). Skipping angle of incidence term for all points." << std::endl;
    }

    for (size_t i = 0; i < pointCloud.rayCount(); ++i) {
        const Eigen::Vector3d& point_pos = pointCloud.ends[i];
        const Eigen::Vector3d& origin_pos = pointCloud.starts[i];

        Eigen::Vector3d d_vec = point_pos - origin_pos;
        double range_squared = d_vec.squaredNorm();

        uint8_t alpha_intensity = pointCloud.colours[i].alpha;
        float normalized_intensity = static_cast<float>(alpha_intensity) / 255.0f;

        double intensity_term = normalized_intensity + epsilon;
        if (intensity_term <= 0) {
            intensity_term = epsilon;
        }

        double range_uncertainty_variance = base_range_variance * (1.0 + c_intensity / intensity_term);
        double angular_uncertainty_variance = range_squared * base_angle_variance;

        double variance_aoi = 0.0;
        if (normals_valid) {
            Eigen::Vector3d ray_vector = point_pos - origin_pos;
            if (ray_vector.squaredNorm() < 1e-12) {
                variance_aoi = c_aoi / epsilon_aoi;
            } else {
                Eigen::Vector3d normalized_ray_dir = ray_vector.normalized();
                const Eigen::Vector3d& surface_normal_at_point = surface_normals[i];

                if (surface_normal_at_point.squaredNorm() < 1e-12) {
                     variance_aoi = c_aoi / epsilon_aoi;
                } else {
                    Eigen::Vector3d normalized_surface_normal = surface_normal_at_point.normalized();
                    double cos_theta = std::abs(normalized_ray_dir.dot(normalized_surface_normal));
                    variance_aoi = c_aoi / (cos_theta + epsilon_aoi);
                }
            }
        }

        double total_variance = range_uncertainty_variance + angular_uncertainty_variance + variance_aoi;
        uncertainties.push_back(total_variance);
    }
    return uncertainties;
}

void print_usage(int exit_code = 1) {
    // clang-format off
    std::cout << "raynoise: Calculates positional uncertainty for point cloud data." << std::endl;
    std::cout << "Usage: raynoise <input_file> <output_file> [options]" << std::endl;
    std::cout << std::endl;
    std::cout << "Required arguments:" << std::endl;
    std::cout << "  <input_file>          Input point cloud file (PLY or LAZ)" << std::endl;
    std::cout << "  <output_file>         Output point cloud file with uncertainty" << std::endl;
    std::cout << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  --base_range_accuracy <value> (-r <value>)" << std::endl;
    std::cout << "                        Sensor's base 1-sigma range accuracy (m)." << std::endl;
    std::cout << "                        Default: 0.02" << std::endl;
    std::cout << "  --base_angle_accuracy <value> (-a <value>)" << std::endl;
    std::cout << "                        Sensor's base 1-sigma angular accuracy (rad)." << std::endl;
    std::cout << "                        Default: 0.0035" << std::endl;
    std::cout << "  --c_intensity <value> (-c <value>)" << std::endl;
    std::cout << "                        Coefficient for intensity effect." << std::endl;
    std::cout << "                        Default: 0.5" << std::endl;
    std::cout << "  --epsilon <value> (-e <value>)" << std::endl;
    std::cout << "                        Small value for intensity division (intensity term)." << std::endl;
    std::cout << "                        Default: 0.01" << std::endl;
    std::cout << "  --c_aoi <value>" << std::endl; // No short option
    std::cout << "                        Coefficient for angle of incidence effect." << std::endl;
    std::cout << "                        Default: 0.1" << std::endl;
    std::cout << "  --epsilon_aoi <value>" << std::endl; // No short option
    std::cout << "                        Small value for angle of incidence division." << std::endl;
    std::cout << "                        Default: 0.01" << std::endl;
    std::cout << "  --help (-h)           Print this usage message." << std::endl;
    // clang-format on
    exit(exit_code);
}

int rayNoiseMain(int argc, char* argv[]) {
    ray::FileArgument inputFile;
    ray::FileArgument outputFile;

    ray::DoubleArgument baseRangeAccuracyArg(0.0, 10.0, 0.02);
    ray::DoubleArgument baseAngleAccuracyArg(0.0, 1.0, 0.0035);
    ray::DoubleArgument cIntensityArg(0.0, 100.0, 0.5);
    ray::DoubleArgument epsilonArg(1e-9, 1.0, 0.01);
    ray::DoubleArgument cAoiArg(0.0, 10.0, 0.1);
    ray::DoubleArgument epsilonAoiArg(1e-9, 1.0, 0.01);

    ray::OptionalFlagArgument helpFlag("help", 'h');
    ray::OptionalKeyValueArgument baseRangeOpt("base_range_accuracy", 'r', &baseRangeAccuracyArg);
    ray::OptionalKeyValueArgument baseAngleOpt("base_angle_accuracy", 'a', &baseAngleAccuracyArg);
    ray::OptionalKeyValueArgument cIntensityOpt("c_intensity", 'c', &cIntensityArg);
    ray::OptionalKeyValueArgument epsilonOpt("epsilon", 'e', &epsilonArg);
    ray::OptionalKeyValueArgument cAoiOpt("c_aoi", '\0', &cAoiArg);
    ray::OptionalKeyValueArgument epsilonAoiOpt("epsilon_aoi", '\0', &epsilonAoiArg);

    std::vector<ray::FixedArgument*> fixedArgs = {&inputFile, &outputFile};
    std::vector<ray::OptionalArgument*> optionalArgs = {
        &helpFlag, &baseRangeOpt, &baseAngleOpt, &cIntensityOpt, &epsilonOpt,
        &cAoiOpt, &epsilonAoiOpt
    };

    if (!ray::parseCommandLine(argc, argv, fixedArgs, optionalArgs)) {
        if (argc == 1 || helpFlag.isSet()) {
             print_usage(0);
        }
        print_usage(1);
    }
     if (helpFlag.isSet()) {
        print_usage(0);
    }

    std::string input_file_str = inputFile.name();
    std::string output_file_str = outputFile.name();

    double base_range_accuracy = baseRangeAccuracyArg.value();
    double base_angle_accuracy = baseAngleAccuracyArg.value();
    double c_intensity = cIntensityArg.value();
    double epsilon = epsilonArg.value();
    double c_aoi = cAoiArg.value();
    double epsilon_aoi = epsilonAoiArg.value();

    if (epsilon <= 0 || epsilon_aoi <= 0) {
        std::cerr << "Error: Epsilon values (epsilon, epsilon_aoi) must be positive." << std::endl;
        print_usage(1);
    }

    ray::Cloud pointCloud;
    if (!pointCloud.load(input_file_str, true, 0)) {
        std::cerr << "Error: Could not load point cloud from " << input_file_str << std::endl;
        return 1;
    }

    if (pointCloud.rayCount() == 0) {
        std::vector<double> empty_uncertainties;
        if (!saveRayCloudWithUncertainty(output_file_str, pointCloud, empty_uncertainties)) {
             std::cerr << "Error: Failed to save empty point cloud header." << std::endl;
             return 1;
        }
        std::cout << "Input point cloud is empty. Saved empty PLY with headers to " << output_file_str << std::endl;
        return 0;
    }

    if (pointCloud.starts.size() != pointCloud.rayCount() ||
        pointCloud.ends.size() != pointCloud.rayCount() ||
        pointCloud.colours.size() != pointCloud.rayCount() ||
        pointCloud.times.size() != pointCloud.rayCount()) {
        std::cerr << "Error: Inconsistent data sizes in loaded point cloud." << std::endl;
        return 1;
    }

    std::vector<double> uncertainties = CalculatePointUncertainty(
        pointCloud, base_range_accuracy, base_angle_accuracy, c_intensity, epsilon, c_aoi, epsilon_aoi);

    if (!saveRayCloudWithUncertainty(output_file_str, pointCloud, uncertainties)) {
        std::cerr << "Error: Failed to save point cloud with uncertainty to " << output_file_str << std::endl;
        return 1;
    }
    std::cout << "Successfully processed and saved point cloud with uncertainty to " << output_file_str << std::endl;

    return 0;
}

int main(int argc, char* argv[]) {
    return rayNoiseMain(argc, argv);
}
