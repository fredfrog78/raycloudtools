// Copyright (c) 2023
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Jules Helper

#include "raylib/raycloud.h"
#include "raylib/rayparse.h"
#include "raylib/rayply.h" // Added for chunked PLY writing
#include <nabo/nabo.h>      // For Nabo C++ interface, Nabo::NNSearchD, Nabo::runtime_error
#include <stdexcept>      // For std::runtime_error (though Nabo might have its own)
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
#include <memory>           // For std::unique_ptr
#include <algorithm>        // For std::min, std::max
#include <numeric>          // For std::iota (if used, currently not)


// Define the struct to hold all uncertainty components
struct UncertaintyComponents {
    double total_v;     // Total variance
    double range_v;     // Range uncertainty component
    double angular_v;   // Angular uncertainty component
    double aoi_v;       // Angle of incidence uncertainty component
    double mixed_pixel_v; // New component
};

// TEMPORARY: Assume common defaults if raylibconfig.h isn't easily included by a tool's cpp directly.
// This should ideally come from a config header.
#ifndef RAYLIB_DOUBLE_RAYS
#define RAYLIB_DOUBLE_RAYS 0 // common default
#endif
#ifndef RAYLIB_WITH_NORMAL_FIELD
#define RAYLIB_WITH_NORMAL_FIELD 1 // common default
#endif

bool saveRayCloudWithUncertainty(
    const std::string& file_name,
    const ray::Cloud& cloud,
    const std::vector<UncertaintyComponents>& all_uncertainties)
{
    if (cloud.rayCount() == 0) {
        std::ofstream ofs(file_name, std::ios::binary | std::ios::out);
        if (!ofs) {
            std::cerr << "Error: Cannot open " << file_name << " for writing." << std::endl;
            return false;
        }
        ofs << "ply" << std::endl;
        ofs << "format binary_little_endian 1.0" << std::endl;
        ofs << "comment generated by raynoise tool - empty cloud" << std::endl;
        ofs << "element vertex 0" << std::endl;
#if RAYLIB_DOUBLE_RAYS
        ofs << "property double x" << std::endl;
        ofs << "property double y" << std::endl;
        ofs << "property double z" << std::endl;
#else
        ofs << "property float x" << std::endl;
        ofs << "property float y" << std::endl;
        ofs << "property float z" << std::endl;
#endif
        ofs << "property double time" << std::endl;
#if RAYLIB_WITH_NORMAL_FIELD
        ofs << "property float nx" << std::endl;
        ofs << "property float ny" << std::endl;
        ofs << "property float nz" << std::endl;
#else
        ofs << "property float rayx" << std::endl;
        ofs << "property float rayy" << std::endl;
        ofs << "property float rayz" << std::endl;
#endif
        ofs << "property uchar red" << std::endl;
        ofs << "property uchar green" << std::endl;
        ofs << "property uchar blue" << std::endl;
        ofs << "property uchar alpha" << std::endl;
        ofs << "property double total_variance" << std::endl;
        ofs << "property double range_variance" << std::endl;
        ofs << "property double angular_variance" << std::endl;
        ofs << "property double aoi_variance" << std::endl;
        ofs << "property double mixed_pixel_variance" << std::endl;
        ofs << "end_header" << std::endl;
        ofs.close();
        return true;
    }

    if (cloud.rayCount() != all_uncertainties.size()) {
        std::cerr << "Error: Mismatch between point cloud size (" << cloud.rayCount()
                  << ") and uncertainties vector size (" << all_uncertainties.size() << ")." << std::endl;
        return false;
    }

    std::ofstream ofs(file_name, std::ios::binary | std::ios::out);
    if (!ofs) {
        std::cerr << "Error: Cannot open " << file_name << " for writing." << std::endl;
        return false;
    }

    ofs << "ply" << std::endl;
    ofs << "format binary_little_endian 1.0" << std::endl;
    ofs << "comment generated by raynoise tool" << std::endl;
    ofs << "element vertex " << cloud.rayCount() << std::endl;

#if RAYLIB_DOUBLE_RAYS
    ofs << "property double x" << std::endl;
    ofs << "property double y" << std::endl;
    ofs << "property double z" << std::endl;
    using coord_type = double;
#else
    ofs << "property float x" << std::endl;
    ofs << "property float y" << std::endl;
    ofs << "property float z" << std::endl;
    using coord_type = float;
#endif

    ofs << "property double time" << std::endl;

#if RAYLIB_WITH_NORMAL_FIELD
    ofs << "property float nx" << std::endl;
    ofs << "property float ny" << std::endl;
    ofs << "property float nz" << std::endl;
#else
    ofs << "property float rayx" << std::endl;
    ofs << "property float rayy" << std::endl;
    ofs << "property float rayz" << std::endl;
#endif
    using ray_comp_type = float;

    ofs << "property uchar red" << std::endl;
    ofs << "property uchar green" << std::endl;
    ofs << "property uchar blue" << std::endl;
    ofs << "property uchar alpha" << std::endl;

    ofs << "property double total_variance" << std::endl;
    ofs << "property double range_variance" << std::endl;
    ofs << "property double angular_variance" << std::endl;
    ofs << "property double aoi_variance" << std::endl;
    ofs << "property double mixed_pixel_variance" << std::endl;
    using uncertainty_comp_type = double;

    ofs << "end_header" << std::endl;

    for (size_t i = 0; i < cloud.rayCount(); ++i) {
        coord_type px = static_cast<coord_type>(cloud.ends[i].x());
        coord_type py = static_cast<coord_type>(cloud.ends[i].y());
        coord_type pz = static_cast<coord_type>(cloud.ends[i].z());
        ofs.write(reinterpret_cast<const char*>(&px), sizeof(coord_type));
        ofs.write(reinterpret_cast<const char*>(&py), sizeof(coord_type));
        ofs.write(reinterpret_cast<const char*>(&pz), sizeof(coord_type));

        double time_val = cloud.times[i];
        ofs.write(reinterpret_cast<const char*>(&time_val), sizeof(double));

        Eigen::Vector3d ray_vec = cloud.starts[i] - cloud.ends[i];
        ray_comp_type rvx = static_cast<ray_comp_type>(ray_vec.x());
        ray_comp_type rvy = static_cast<ray_comp_type>(ray_vec.y());
        ray_comp_type rvz = static_cast<ray_comp_type>(ray_vec.z());
        ofs.write(reinterpret_cast<const char*>(&rvx), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&rvy), sizeof(ray_comp_type));
        ofs.write(reinterpret_cast<const char*>(&rvz), sizeof(ray_comp_type));

        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].red), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].green), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].blue), sizeof(uint8_t));
        ofs.write(reinterpret_cast<const char*>(&cloud.colours[i].alpha), sizeof(uint8_t));

        uncertainty_comp_type total_v_val = all_uncertainties[i].total_v;
        uncertainty_comp_type range_v_val = all_uncertainties[i].range_v;
        uncertainty_comp_type angular_v_val = all_uncertainties[i].angular_v;
        uncertainty_comp_type aoi_v_val = all_uncertainties[i].aoi_v;
        uncertainty_comp_type mixed_v_val = all_uncertainties[i].mixed_pixel_v;

        ofs.write(reinterpret_cast<const char*>(&total_v_val), sizeof(uncertainty_comp_type));
        ofs.write(reinterpret_cast<const char*>(&range_v_val), sizeof(uncertainty_comp_type));
        ofs.write(reinterpret_cast<const char*>(&angular_v_val), sizeof(uncertainty_comp_type));
        ofs.write(reinterpret_cast<const char*>(&aoi_v_val), sizeof(uncertainty_comp_type));
        ofs.write(reinterpret_cast<const char*>(&mixed_v_val), sizeof(uncertainty_comp_type));

        if (!ofs.good()) {
            std::cerr << "Error: Failed to write data for point " << i << " to " << file_name << std::endl;
            ofs.close();
            return false;
        }
    }

    ofs.close();
    std::cout << "Successfully saved point cloud with detailed uncertainties (including mixed pixel) to " << file_name << std::endl;
    return true;
}

std::vector<UncertaintyComponents> CalculatePointUncertainty(
    const ray::Cloud& pointCloud,
    double base_range_accuracy,
    double base_angle_accuracy,
    double c_intensity,
    double epsilon,
    double c_aoi,
    double epsilon_aoi,
    int k_mixed_neighbors,
    double depth_threshold_mixed,
    int min_front_neighbors_mixed,
    int min_behind_neighbors_mixed,
    double variance_mixed_pixel_penalty,
    bool is_chunked_mode = false)
{
    static bool aoi_warning_issued = false;
    static bool mixed_pixel_warning_issued = false;

    std::vector<UncertaintyComponents> all_uncertainties;
    if (pointCloud.rayCount() == 0) {
        return all_uncertainties;
    }
    all_uncertainties.reserve(pointCloud.rayCount());

    double base_range_variance = std::pow(base_range_accuracy, 2);
    double base_angle_variance = std::pow(base_angle_accuracy, 2);

    // --- Normal Generation ---
    std::vector<Eigen::Vector3d> surface_normals;
    bool normals_valid = false;
    if (is_chunked_mode) {
        if (!aoi_warning_issued) {
            std::cout << "Warning: Chunked mode active. AoI calculation is simplified (using fallback as normals are not computed per chunk), potentially impacting accuracy. AoI variance may be less precise." << std::endl;
            aoi_warning_issued = true;
        }
        // Normals_valid remains false, AoI will use fallback.
    } else {
        const int default_normal_search_size = 16; // Default k for generateNormals in raylib
        if (pointCloud.rayCount() > static_cast<size_t>(default_normal_search_size)) {
            ray::Cloud tempCloud = pointCloud; // Make a mutable copy for generateNormals
            surface_normals = tempCloud.generateNormals(default_normal_search_size);
            if (surface_normals.size() == pointCloud.rayCount()) {
                normals_valid = true;
            } else {
                std::cerr << "Warning: Normal generation (default k) returned " << surface_normals.size()
                          << " normals for " << pointCloud.rayCount()
                          << " points. AoI component may be inaccurate." << std::endl;
            }
        } else if (pointCloud.rayCount() > 1) {
            ray::Cloud tempCloud = pointCloud; // Make a mutable copy
            int adaptive_search_size = std::max(1, static_cast<int>(pointCloud.rayCount()) - 1);
            surface_normals = tempCloud.generateNormals(adaptive_search_size);
            if (surface_normals.size() == pointCloud.rayCount()) {
                normals_valid = true;
            } else {
                std::cerr << "Warning: Normal generation (adaptive k) returned " << surface_normals.size()
                          << " normals for " << pointCloud.rayCount()
                          << " points. AoI component may be inaccurate." << std::endl;
            }
        } else {
            if (pointCloud.rayCount() > 0) {
                 std::cerr << "Warning: Only " << pointCloud.rayCount()
                           << " point(s) in cloud. Cannot generate reliable surface normals. AoI component will use fallback." << std::endl;
            }
        }
    }

    // --- Mixed Pixel Detection Setup ---
    std::unique_ptr<Nabo::NNSearchD> nns;
    if (is_chunked_mode) {
        if (!mixed_pixel_warning_issued) {
            std::cout << "Warning: Chunked mode active. Mixed Pixel detection is disabled. Mixed pixel variance contribution will be zero." << std::endl;
            mixed_pixel_warning_issued = true;
        }
        // nns remains nullptr, mixed pixel calculation will be skipped.
    } else {
        Eigen::MatrixXd cloud_matrix_eigen;
        if (k_mixed_neighbors > 0 && pointCloud.rayCount() > static_cast<size_t>(k_mixed_neighbors)) {
            cloud_matrix_eigen.resize(3, pointCloud.rayCount());
            for (size_t pt_idx = 0; pt_idx < pointCloud.rayCount(); ++pt_idx) {
                cloud_matrix_eigen.col(pt_idx) = pointCloud.ends[pt_idx];
            }
            try {
                nns.reset(Nabo::NNSearchD::createKDTreeLinearHeap(cloud_matrix_eigen));
            } catch (const std::runtime_error& e) { // Changed to std::runtime_error
                std::cerr << "Nabo KD-tree creation failed (caught as std::runtime_error): " << e.what() << std::endl;
                nns.reset();
            }
        }
    }

    for (size_t i = 0; i < pointCloud.rayCount(); ++i) {
        const Eigen::Vector3d& point_pos = pointCloud.ends[i];
        const Eigen::Vector3d& origin_pos = pointCloud.starts[i];

        Eigen::Vector3d d_vec = point_pos - origin_pos;
        double range_squared = d_vec.squaredNorm();

        uint8_t alpha_intensity = pointCloud.colours[i].alpha;
        float normalized_intensity = static_cast<float>(alpha_intensity) / 255.0f;
        double intensity_term = normalized_intensity + epsilon;
        if (intensity_term <= 0) { intensity_term = epsilon; }

        double current_range_v = base_range_variance * (1.0 + c_intensity / intensity_term);
        double current_angular_v = range_squared * base_angle_variance;
        double current_aoi_v = 0.0;

        if (normals_valid) {
            Eigen::Vector3d ray_vector_aoi = point_pos - origin_pos;
            if (ray_vector_aoi.squaredNorm() < 1e-12) {
                current_aoi_v = c_aoi / epsilon_aoi;
            } else {
                Eigen::Vector3d normalized_ray_dir_aoi = ray_vector_aoi.normalized();
                const Eigen::Vector3d& surface_normal_at_point = surface_normals[i];
                if (surface_normal_at_point.squaredNorm() < 1e-12) {
                    current_aoi_v = c_aoi / epsilon_aoi;
                } else {
                    Eigen::Vector3d normalized_surface_normal = surface_normal_at_point.normalized();
                    double cos_theta = std::abs(normalized_ray_dir_aoi.dot(normalized_surface_normal));
                    current_aoi_v = c_aoi / (cos_theta + epsilon_aoi);
                }
            }
        } else {
            current_aoi_v = c_aoi / epsilon_aoi;
        }

        double current_mixed_pixel_v = 0.0;
        if (nns) {
            Eigen::VectorXi indices(k_mixed_neighbors + 1);
            Eigen::VectorXd dists2(k_mixed_neighbors + 1);
            Eigen::Vector3d query_point = pointCloud.ends[i];

            try {
                nns->knn(query_point, indices, dists2, k_mixed_neighbors + 1);

                Eigen::Vector3d ray_P_i = pointCloud.ends[i] - pointCloud.starts[i];
                double ray_P_i_norm = ray_P_i.norm();
                Eigen::Vector3d normalized_ray_P_i;
                bool ray_P_i_is_valid = (ray_P_i_norm > 1e-9);

                if(ray_P_i_is_valid) {
                    normalized_ray_P_i = ray_P_i / ray_P_i_norm;
                    int count_front = 0;
                    int count_behind = 0;
                    for (int k_idx = 0; k_idx < k_mixed_neighbors + 1; ++k_idx) {
                        int neighbor_idx = indices(k_idx);
                        if (static_cast<size_t>(neighbor_idx) == i) continue;

                        Eigen::Vector3d vec_origin_Pi_to_Pj_end = pointCloud.ends[neighbor_idx] - pointCloud.starts[i];
                        double depth_Pj_on_rayPi = vec_origin_Pi_to_Pj_end.dot(normalized_ray_P_i);
                        double depth_Pi_on_rayPi = ray_P_i_norm;
                        double depth_diff = depth_Pj_on_rayPi - depth_Pi_on_rayPi;

                        if (depth_diff < -depth_threshold_mixed) {
                            count_front++;
                        }
                        if (depth_diff > depth_threshold_mixed) {
                            count_behind++;
                        }
                    }
                    if (count_front >= min_front_neighbors_mixed && count_behind >= min_behind_neighbors_mixed) {
                        current_mixed_pixel_v = variance_mixed_pixel_penalty;
                    }
                }
            } catch (const std::runtime_error& e) { // Changed to std::runtime_error
                std::cerr << "Nabo kNN search failed for point " << i << " (caught as std::runtime_error): " << e.what() << std::endl;
            }
        }

        double current_total_v = current_range_v + current_angular_v + current_aoi_v + current_mixed_pixel_v;
        all_uncertainties.push_back({current_total_v, current_range_v, current_angular_v, current_aoi_v, current_mixed_pixel_v});
    }
    return all_uncertainties;
}

void print_usage(int exit_code = 1) {
    // clang-format off
    std::cout << "raynoise: Calculates positional uncertainty for point cloud data." << std::endl;
    std::cout << "Usage: raynoise <input_file> <output_file> [options]" << std::endl;
    std::cout << std::endl;
    std::cout << "Required arguments:" << std::endl;
    std::cout << "  <input_file>          Input point cloud file (PLY or LAZ)" << std::endl;
    std::cout << "  <output_file>         Output point cloud file with uncertainty" << std::endl;
    std::cout << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  --base_range_accuracy <value> (-r <value>)" << std::endl;
    std::cout << "                        Sensor's base 1-sigma range accuracy (m). Default: 0.02" << std::endl;
    std::cout << "  --base_angle_accuracy <value> (-a <value>)" << std::endl;
    std::cout << "                        Sensor's base 1-sigma angular accuracy (rad). Default: 0.0035" << std::endl;
    std::cout << "  --c_intensity <value> (-c <value>)" << std::endl;
    std::cout << "                        Coefficient for intensity effect. Default: 0.5" << std::endl;
    std::cout << "  --epsilon <value> (-e <value>)" << std::endl;
    std::cout << "                        Small value for intensity division (intensity term). Default: 0.01" << std::endl;
    std::cout << "  --c_aoi <value>" << std::endl;
    std::cout << "                        Coefficient for angle of incidence effect. Default: 0.1" << std::endl;
    std::cout << "  --epsilon_aoi <value>" << std::endl;
    std::cout << "                        Small value for angle of incidence division. Default: 0.01" << std::endl;
    std::cout << "  --k_mixed <value>" << std::endl;
    std::cout << "                        Number of neighbors for mixed pixel detection. Default: 8" << std::endl;
    std::cout << "  --depth_thresh_mixed <value>" << std::endl;
    std::cout << "                        Depth threshold for mixed pixel detection (m). Default: 0.05" << std::endl;
    std::cout << "  --min_front_mixed <value>" << std::endl;
    std::cout << "                        Min front neighbors for mixed pixel detection. Default: 1" << std::endl;
    std::cout << "  --min_behind_mixed <value>" << std::endl;
    std::cout << "                        Min behind neighbors for mixed pixel detection. Default: 1" << std::endl;
    std::cout << "  --penalty_mixed <value>" << std::endl;
    std::cout << "                        Variance penalty for detected mixed pixels (m^2). Default: 0.5" << std::endl;
    std::cout << "  --chunk_size <value>" << std::endl;
    std::cout << "                        Process points in chunks of <N> points. Useful for large files to reduce" << std::endl;
    std::cout << "                        memory usage. Note: In chunked mode, Angle of Incidence (AoI) and" << std::endl;
    std::cout << "                        Mixed Pixel uncertainty calculations are currently simplified/disabled," << std::endl;
    std::cout << "                        potentially affecting accuracy or setting their variance contributions to zero." << std::endl;
    std::cout << "                        Default: 0 (off)" << std::endl;
    std::cout << "  --help (-h)           Print this usage message." << std::endl;
    // clang-format on
    exit(exit_code);
}

int rayNoiseMain(int argc, char* argv[]) {
    ray::FileArgument inputFile;
    ray::FileArgument outputFile;

    ray::DoubleArgument baseRangeAccuracyArg(0.0, 10.0, 0.02);
    ray::DoubleArgument baseAngleAccuracyArg(0.0, 1.0, 0.0035);
    ray::DoubleArgument cIntensityArg(0.0, 100.0, 0.5);
    ray::DoubleArgument epsilonArg(1e-9, 1.0, 0.01);
    ray::DoubleArgument cAoiArg(0.0, 10.0, 0.1);
    ray::DoubleArgument epsilonAoiArg(1e-9, 1.0, 0.01);

    ray::IntArgument kMixedNeighborsArg(1, 50, 8);
    ray::DoubleArgument depthThreshMixedArg(0.001, 10.0, 0.05);
    ray::IntArgument minFrontMixedArg(1, 50, 1);
    ray::IntArgument minBehindMixedArg(1, 50, 1);
    ray::DoubleArgument penaltyMixedArg(0.0, 100.0, 0.5);
    ray::IntArgument chunkSizeArg(0, 10000000, 0); // Min 0 (off), Max 10M, Default 0

    ray::OptionalFlagArgument helpFlag("help", 'h');
    ray::OptionalKeyValueArgument baseRangeOpt("base_range_accuracy", 'r', &baseRangeAccuracyArg);
    ray::OptionalKeyValueArgument baseAngleOpt("base_angle_accuracy", 'a', &baseAngleAccuracyArg);
    ray::OptionalKeyValueArgument cIntensityOpt("c_intensity", 'c', &cIntensityArg);
    ray::OptionalKeyValueArgument epsilonOpt("epsilon", 'e', &epsilonArg);
    ray::OptionalKeyValueArgument cAoiOpt("c_aoi", '\0', &cAoiArg);
    ray::OptionalKeyValueArgument epsilonAoiOpt("epsilon_aoi", '\0', &epsilonAoiArg);
    ray::OptionalKeyValueArgument kMixedOpt("k_mixed", '\0', &kMixedNeighborsArg);
    ray::OptionalKeyValueArgument depthThreshMixedOpt("depth_thresh_mixed", '\0', &depthThreshMixedArg);
    ray::OptionalKeyValueArgument minFrontMixedOpt("min_front_mixed", '\0', &minFrontMixedArg);
    ray::OptionalKeyValueArgument minBehindMixedOpt("min_behind_mixed", '\0', &minBehindMixedArg);
    ray::OptionalKeyValueArgument penaltyMixedOpt("penalty_mixed", '\0', &penaltyMixedArg);
    ray::OptionalKeyValueArgument chunkSizeOpt("chunk_size", '\0', &chunkSizeArg);

    std::vector<ray::FixedArgument*> fixedArgs = {&inputFile, &outputFile};
    std::vector<ray::OptionalArgument*> optionalArgs = {
        &helpFlag, &baseRangeOpt, &baseAngleOpt, &cIntensityOpt, &epsilonOpt,
        &cAoiOpt, &epsilonAoiOpt,
        &kMixedOpt, &depthThreshMixedOpt, &minFrontMixedOpt, &minBehindMixedOpt, &penaltyMixedOpt,
        &chunkSizeOpt
    };

    if (!ray::parseCommandLine(argc, argv, fixedArgs, optionalArgs)) {
        if (argc == 1 || helpFlag.isSet()) {
             print_usage(0);
        }
        print_usage(1);
    }
     if (helpFlag.isSet()) {
        print_usage(0);
    }

    std::string input_file_str = inputFile.name();
    std::string output_file_str = outputFile.name();

    double base_range_accuracy = baseRangeAccuracyArg.value();
    double base_angle_accuracy = baseAngleAccuracyArg.value();
    double c_intensity = cIntensityArg.value();
    double epsilon = epsilonArg.value();
    double c_aoi = cAoiArg.value();
    double epsilon_aoi = epsilonAoiArg.value();
    int k_mixed_neighbors = kMixedNeighborsArg.value();
    double depth_threshold_mixed = depthThreshMixedArg.value();
    int min_front_neighbors_mixed = minFrontMixedArg.value();
    int min_behind_neighbors_mixed = minBehindMixedArg.value();
    double variance_mixed_pixel_penalty = penaltyMixedArg.value();
    int chunk_size = chunkSizeArg.value();

    if (epsilon <= 0 || epsilon_aoi <= 0 || depth_threshold_mixed <=0) {
        std::cerr << "Error: Epsilon values (epsilon, epsilon_aoi) and depth_threshold_mixed must be positive." << std::endl;
        print_usage(1);
    }
    if (k_mixed_neighbors <= 0 || min_front_neighbors_mixed <=0 || min_behind_neighbors_mixed <=0) {
        std::cerr << "Error: Neighbor counts (k_mixed, min_front_mixed, min_behind_mixed) must be positive." << std::endl;
        print_usage(1);
    }
    if (chunk_size < 0) { // Should be caught by IntArgument min, but good practice.
        std::cerr << "Error: chunk_size must be non-negative." << std::endl;
        print_usage(1);
    }

    if (chunk_size > 0) {
        std::cout << "Chunked processing active with chunk_size: " << chunk_size << std::endl;

        std::ofstream out_ply_stream;
        out_ply_stream.open(output_file_str, std::ios::binary | std::ios::out);
        if (!out_ply_stream) {
            std::cerr << "Error: Cannot open " << output_file_str << " for writing." << std::endl;
            return 1;
        }

        unsigned long vertex_count_pos = 0;
        if (!ray::writeRayNoisePlyHeader(out_ply_stream, vertex_count_pos)) {
            std::cerr << "Error: Failed to write PLY header to " << output_file_str << std::endl;
            out_ply_stream.close();
            return 1;
        }

        unsigned long total_points_written = 0;
        bool chunk_write_error = false; // Flag to signal error from lambda

        // Lambda needs to capture out_ply_stream, total_points_written, output_file_str, and error flag
        // Also, all the parameters for CalculatePointUncertainty
        auto apply_chunk = [&](std::vector<Eigen::Vector3d>& starts_vec, // Renamed from 'starts' to avoid conflict if any param had same name
                               std::vector<Eigen::Vector3d>& ends_vec,
                               std::vector<double>& times_vec,
                               std::vector<ray::RGBA>& colours_vec) {
            if (chunk_write_error) return; // Stop processing if a previous chunk failed to write

            if (ends_vec.empty()) {
                std::cout << "Received an empty chunk." << std::endl;
                return;
            }
            // std::cout << "Processing chunk of " << ends_vec.size() << " points." << std::endl; // Verbose

            ray::Cloud chunk_cloud;
            // The input vectors to the lambda are rvalue references if moved from,
            // but here they are passed as lvalue refs from readPly's internal loop.
            // To avoid issues with readPly reusing buffers (if it does), we should copy or ensure it's safe.
            // Assuming readPly provides fresh vectors or we consume them fully.
            // For safety in this step, let's copy. If performance becomes an issue, std::move could be revisited
            // with deeper analysis of readPly's behavior.
            // However, the function signature for readPly's apply is `std::function<void(std::vector<Eigen::Vector3d> &starts, ...`
            // which means these are lvalues, not rvalues. So std::move is not appropriate here.
            chunk_cloud.starts = starts_vec;
            chunk_cloud.ends = ends_vec;
            chunk_cloud.times = times_vec;
            chunk_cloud.colours = colours_vec;

            std::vector<UncertaintyComponents> chunk_uncertainties = CalculatePointUncertainty(
                chunk_cloud, base_range_accuracy, base_angle_accuracy, c_intensity, epsilon,
                c_aoi, epsilon_aoi,
                k_mixed_neighbors, depth_threshold_mixed, min_front_neighbors_mixed,
                min_behind_neighbors_mixed, variance_mixed_pixel_penalty, true /* is_chunked_mode */);

            // std::cout << "Calculated uncertainties for chunk of " << chunk_cloud.rayCount() << " points." << std::endl; // Verbose

            std::vector<ray::RayNoiseUncertaintyData> rayply_uncertainties;
            rayply_uncertainties.reserve(chunk_uncertainties.size());
            for (const auto& src_unc : chunk_uncertainties) {
                ray::RayNoiseUncertaintyData dest_unc;
                dest_unc.total_v = src_unc.total_v;
                dest_unc.range_v = src_unc.range_v;
                dest_unc.angular_v = src_unc.angular_v;
                dest_unc.aoi_v = src_unc.aoi_v;
                dest_unc.mixed_pixel_v = src_unc.mixed_pixel_v;
                rayply_uncertainties.push_back(dest_unc);
            }

            if (!ray::writeRayNoisePlyChunk(out_ply_stream,
                                         chunk_cloud.starts,
                                         chunk_cloud.ends,
                                         chunk_cloud.times,
                                         chunk_cloud.colours,
                                         rayply_uncertainties)) {
                std::cerr << "Error: Failed to write chunk to " << output_file_str << std::endl;
                chunk_write_error = true; // Signal error to stop further processing
            } else {
                total_points_written += chunk_cloud.rayCount();
            }
        };

        // Note: The lambda signature was: std::vector<Eigen::Vector3d>& starts, std::vector<Eigen::Vector3d>& starts_vec...
        // This was a typo from previous step. readPly provides 4 vectors.
        // Corrected lambda signature for ray::readPly's apply function:
        auto correct_apply_chunk = [&](std::vector<Eigen::Vector3d>& s, // starts
                                   std::vector<Eigen::Vector3d>& e, // ends
                                   std::vector<double>& t,      // times
                                   std::vector<ray::RGBA>& c) { // colours
            // Call the previous lambda logic with correct variable names
            apply_chunk(s, e, t, c);
        };


        bool success = ray::readPly(input_file_str, true, correct_apply_chunk, 0, false, chunk_size);

        if (!success && !chunk_write_error) { // if readPly itself failed, not due to our write error
            std::cerr << "Error: Failed to process input file in chunks: " << input_file_str << std::endl;
            out_ply_stream.close();
            return 1;
        }

        if (chunk_write_error) {
             std::cerr << "Due to previous error, chunk processing stopped." << std::endl;
             // Try to finalize with what we have, or just clean up.
        }

        if (!ray::finalizeRayNoisePlyHeader(out_ply_stream, total_points_written, vertex_count_pos)) {
            std::cerr << "Error: Failed to finalize PLY header for " << output_file_str << std::endl;
            out_ply_stream.close();
            return 1;
        }

        out_ply_stream.close();
        if (!chunk_write_error) {
            std::cout << "Successfully saved " << total_points_written << " points with uncertainty to "
                      << output_file_str << " (chunked)." << std::endl;
        } else {
            std::cout << "Attempted to save point cloud with " << total_points_written
                      << " points to " << output_file_str << " (chunked), but errors occurred." << std::endl;
            return 1; // Indicate error
        }


    } else {
        // Non-Chunked Path (Existing Logic)
        ray::Cloud pointCloud;
        if (!pointCloud.load(input_file_str, true, 0)) {
            std::cerr << "Error: Could not load point cloud from " << input_file_str << std::endl;
            return 1;
        }

        if (pointCloud.rayCount() == 0) {
            std::cout << "Input point cloud is empty (non-chunked path)." << std::endl;
            std::vector<UncertaintyComponents> empty_uncertainties;
            if (!saveRayCloudWithUncertainty(output_file_str, pointCloud, empty_uncertainties)) {
                 std::cerr << "Error: Failed to save empty point cloud header." << std::endl;
                 return 1;
            }
            std::cout << "Saved empty PLY with headers to " << output_file_str << std::endl;
            return 0;
        }

        if (pointCloud.starts.size() != pointCloud.rayCount() ||
            pointCloud.ends.size() != pointCloud.rayCount() ||
            pointCloud.colours.size() != pointCloud.rayCount() ||
            pointCloud.times.size() != pointCloud.rayCount()) {
            std::cerr << "Error: Inconsistent data sizes in loaded point cloud." << std::endl;
            return 1;
        }

        std::vector<UncertaintyComponents> uncertainties = CalculatePointUncertainty(
            pointCloud, base_range_accuracy, base_angle_accuracy, c_intensity, epsilon,
            c_aoi, epsilon_aoi,
            k_mixed_neighbors, depth_threshold_mixed, min_front_neighbors_mixed,
            min_behind_neighbors_mixed, variance_mixed_pixel_penalty, false /* is_chunked_mode */);

        if (!saveRayCloudWithUncertainty(output_file_str, pointCloud, uncertainties)) {
            std::cerr << "Error: Failed to save point cloud with uncertainty to " << output_file_str << std::endl;
            return 1;
        }
    }

    return 0;
}

int main(int argc, char* argv[]) {
    return rayNoiseMain(argc, argv);
}
